"""Code generation for Python MCP server from protobuf service definitions."""

from typing import Any, Dict, List, Optional

from google.protobuf import descriptor_pb2

from .config import CodeGenerationOptions, PluginConfig
from .type_analyzer import TypeAnalyzer


class CodeGenerator:
    """Generates Python MCP server code from protobuf service definitions."""

    def __init__(
        self,
        config: PluginConfig,
        type_analyzer: TypeAnalyzer,
        logger: Optional[Any] = None,
    ):
        """Initialize the code generator.

        Args:
            config: Plugin configuration
            type_analyzer: Type analyzer for protobuf types
            logger: Optional logger for debug output
        """
        self.config = config
        self.type_analyzer = type_analyzer
        self.logger = logger

    def log_debug(self, message: str, level: str = "basic") -> None:
        """Log debug message if logger is available."""
        if self.logger:
            self.logger.log_debug(message, level)

    def generate_file_content(
        self,
        proto_file: descriptor_pb2.FileDescriptorProto,
        services: List[descriptor_pb2.ServiceDescriptorProto],
    ) -> str:
        """
        Generate complete Python MCP server file content.

        Args:
            proto_file: The proto file descriptor
            services: List of service descriptors to generate

        Returns:
            Complete Python file content as string
        """
        lines = []

        # Generate header
        lines.extend(self._generate_header(proto_file))

        # Generate imports
        lines.extend(self._generate_imports(proto_file))

        # Generate request interceptor if needed
        if self.config.use_request_interceptor:
            lines.extend(self._generate_request_interceptor())

        # Generate MCP instance
        lines.extend(self._generate_main_block())

        # Generate each service
        for service_index, service in enumerate(services):
            lines.extend(self._generate_service(service, proto_file, service_index))

        # Generate main block
        lines.extend(["", "if __name__ == '__main__':", "    mcp.run()"])

        return "\n".join(lines)

    def _generate_header(self, proto_file: descriptor_pb2.FileDescriptorProto) -> List[str]:
        """Generate file header with metadata."""
        lines = [
            f"# Generated from {proto_file.name}",
            "# DO NOT EDIT: This file is automatically generated by protoc-gen-py-mcp",
            "# Plugin version: protoc-gen-py-mcp",
            "",
        ]
        return lines

    def _generate_imports(self, proto_file: descriptor_pb2.FileDescriptorProto) -> List[str]:
        """Generate import statements."""
        lines = []

        # Determine if we need typing imports
        has_optional_fields = (
            self.type_analyzer.has_optional_fields(proto_file) if self.type_analyzer else False
        )

        if has_optional_fields:
            lines.append("from typing import Optional")

        # Core imports
        lines.extend(
            [
                "from fastmcp import FastMCP",
                "import grpc",
                "",
            ]
        )

        # Proto-specific imports
        proto_name = proto_file.name.replace(".proto", "")
        lines.extend(
            [
                f"import {proto_name}_pb2",
                f"import {proto_name}_pb2_grpc",
                "",
            ]
        )

        return lines

    def _generate_request_interceptor(self) -> List[str]:
        """Generate default request interceptor function."""
        lines = [
            "",
            "def default_request_interceptor(request, service_name, method_name):",
            '    """Default request interceptor for adding authentication or metadata."""',
            "    # Add your custom authentication logic here",
            "    # Example: Add authentication headers, modify request, etc.",
            "    metadata = []",
            "    return request, metadata",
            "",
        ]
        return lines

    def _generate_main_block(self) -> List[str]:
        """Generate MCP instance creation."""
        server_name = self.config.server_name_pattern.format(service="MCP Server from Proto")
        return [
            f'mcp = FastMCP("{server_name}")',
            "",
            "",
        ]

    def _generate_service(
        self,
        service: descriptor_pb2.ServiceDescriptorProto,
        proto_file: descriptor_pb2.FileDescriptorProto,
        service_index: int,
    ) -> List[str]:
        """Generate code for a single service."""
        lines = []

        # Generate each method in the service
        for method_index, method in enumerate(service.method):
            # Create context inline to avoid circular import
            context = {
                "method": method,
                "service": service,
                "proto_file": proto_file,
                "service_index": service_index,
                "method_index": method_index,
            }

            options = self._create_generation_options()
            lines.extend(self._generate_method_tool(context, options))

        return lines

    def _create_generation_options(self) -> CodeGenerationOptions:
        """Create code generation options from config."""
        return CodeGenerationOptions(
            tool_name_case=self.config.tool_name_case,
            include_comments=self.config.include_comments,
            async_mode=self.config.async_mode,
            stream_mode=self.config.stream_mode,
            grpc_target=self.config.grpc_target,
            grpc_timeout=self.config.grpc_timeout,
            insecure_channel=self.config.insecure_channel,
            use_request_interceptor=self.config.use_request_interceptor,
            show_generated_code=self.config.show_generated_code,
        )

    def _generate_method_tool(
        self,
        context: Dict[str, Any],
        options: CodeGenerationOptions,
    ) -> List[str]:
        """Generate an MCP tool function for a gRPC method."""
        method = context["method"]
        method_name = method.name
        method_name_converted = self._convert_tool_name(method_name, options.tool_name_case)

        # Analyze input message fields to generate function parameters
        input_fields = (
            self.type_analyzer.analyze_message_fields(method.input_type)
            if self.type_analyzer
            else []
        )

        # Generate function signature with parameters
        # Separate required and optional parameters to ensure proper Python syntax
        required_params = []
        optional_params = []

        for field in input_fields:
            if field["optional"]:
                # Avoid double-wrapping oneof fields that are already Optional
                field_type = field["type"]
                if not field_type.startswith("Optional["):
                    field_type = f"Optional[{field_type}]"
                optional_params.append(f"{field['name']}: {field_type} = None")
            else:
                required_params.append(f"{field['name']}: {field['type']}")

        # Check for streaming methods and handle them differently
        if method.client_streaming or method.server_streaming:
            return self._generate_streaming_tool_adapted(context, options)

        # Combine parameters ensuring required come before optional
        all_params = required_params + optional_params
        params_str = ", ".join(all_params)

        lines = [
            f'@mcp.tool(name="{method_name_converted}", description="Generated tool for {method_name} RPC method")',
            f"def {method_name_converted.lower()}({params_str}):",
            f'    """Tool for {method_name} RPC method."""',
        ]

        # Generate method implementation
        lines.extend(self._generate_grpc_call(context, input_fields))

        lines.append("")  # Add blank line after method
        return lines

    def _generate_grpc_call(
        self,
        context: Dict[str, Any],
        input_fields: List[Dict[str, Any]],
    ) -> List[str]:
        """Generate the gRPC call implementation."""
        lines = []
        indentation = "    "

        # Get module name for the proto
        proto_file = context["proto_file"]
        method = context["method"]
        service = context["service"]
        proto_name = proto_file.name.replace(".proto", "")
        input_type_name = method.input_type.split(".")[-1]  # Get the simple name

        lines.extend(
            [
                f"{indentation}# Construct request message",
                f"{indentation}request = {proto_name}_pb2.{input_type_name}()",
            ]
        )

        # Generate oneof validation if needed
        oneofs: Dict[str, List[str]] = {}
        for field in input_fields:
            if field.get("is_oneof", False):
                oneof_name = field["oneof_name"]
                if oneof_name not in oneofs:
                    oneofs[oneof_name] = []
                oneofs[oneof_name].append(field["name"])

        # Add oneof validation comments
        if oneofs:
            lines.append(f"{indentation}# Oneof validation:")
            for oneof_name, field_names in oneofs.items():
                field_list = ", ".join(field_names)
                lines.append(
                    f"{indentation}# Only one of [{field_list}] should be provided for oneof '{oneof_name}'"
                )

        # Generate field assignment code
        for field in input_fields:
            if field["optional"]:
                lines.extend(
                    [
                        f"{indentation}if {field['name']} is not None:",
                        f"{indentation}    request.{field['name']} = {field['name']}",
                    ]
                )
            else:
                lines.append(f"{indentation}request.{field['name']} = {field['name']}")

        # Generate gRPC call
        service_name = service.name
        method_name = method.name
        grpc_target = self.config.grpc_target

        # Generate gRPC call with optional request interceptor
        if self.config.use_request_interceptor:
            lines.extend(
                [
                    "",
                    f"{indentation}# Request interceptor setup",
                    f"{indentation}request_interceptor = default_request_interceptor",
                    f"{indentation}request, metadata = request_interceptor(request, '{service_name}', '{method_name}')",
                    "",
                    f"{indentation}channel = grpc.insecure_channel('{grpc_target}')",
                    f"{indentation}stub = {proto_name}_pb2_grpc.{service_name}Stub(channel)",
                    f"{indentation}response = stub.{method_name}(request, metadata=metadata)",
                ]
            )
        else:
            lines.extend(
                [
                    "",
                    f"{indentation}channel = grpc.insecure_channel('{grpc_target}')",
                    f"{indentation}stub = {proto_name}_pb2_grpc.{service_name}Stub(channel)",
                    f"{indentation}response = stub.{method_name}(request)",
                ]
            )

        lines.extend(
            [
                "",
                f"{indentation}# Convert protobuf response to dict for MCP",
                f"{indentation}from google.protobuf.json_format import MessageToDict",
                f"{indentation}result = MessageToDict(response)",
                f"{indentation}return result",
            ]
        )

        return lines

    def _generate_streaming_tool_adapted(
        self,
        context: Dict[str, Any],
        options: CodeGenerationOptions,
    ) -> List[str]:
        """Generate adapted streaming method handling."""
        method = context["method"]
        method_name = method.name
        method_name_converted = self._convert_tool_name(method_name, options.tool_name_case)

        # Check streaming type
        is_client_stream = method.client_streaming
        is_server_stream = method.server_streaming

        # Check stream mode configuration
        if options.stream_mode == "skip":
            # Skip streaming methods entirely
            return []

        if is_client_stream and is_server_stream:
            # Bidirectional - skip
            return []

        # Analyze input message fields
        input_fields = (
            self.type_analyzer.analyze_message_fields(method.input_type)
            if self.type_analyzer
            else []
        )

        # For client streaming, we'll accept a list of requests
        if is_client_stream:
            # Modify to accept list of inputs
            params = ["requests: List[dict]"]
        else:
            # Regular unary input
            required_params = []
            optional_params = []

            for field in input_fields:
                if field["optional"]:
                    # Avoid double-wrapping oneof fields that are already Optional
                    field_type = field["type"]
                    if not field_type.startswith("Optional["):
                        field_type = f"Optional[{field_type}]"
                    optional_params.append(f"{field['name']}: {field_type} = None")
                else:
                    required_params.append(f"{field['name']}: {field['type']}")

            params = required_params + optional_params

        params_str = ", ".join(params)

        lines = [
            f'@mcp.tool(name="{method_name_converted}", description="Generated tool for {method_name} RPC method (streaming adapted)")',
            f"def {method_name_converted.lower()}({params_str}):",
            f'    """Tool for {method_name} RPC method (streaming)."""',
            "    # Note: Streaming methods are adapted for MCP compatibility",
            "    # This is a placeholder implementation",
            "    return {'error': 'Streaming methods not yet fully supported'}",
            "",
        ]

        return lines

    def _convert_tool_name(self, name: str, case: str) -> str:
        """Convert tool name to specified case."""
        if case == "snake":
            return self._camel_to_snake(name)
        elif case == "camel":
            return name[0].lower() + name[1:] if name else name
        elif case == "pascal":
            return name
        elif case == "kebab":
            return self._camel_to_snake(name).replace("_", "-")
        else:
            # Default to snake case
            return self._camel_to_snake(name)

    def _camel_to_snake(self, name: str) -> str:
        """Convert CamelCase to snake_case."""
        result = []
        for i, char in enumerate(name):
            if char.isupper() and i > 0:
                result.append("_")
            result.append(char.lower())
        return "".join(result)
